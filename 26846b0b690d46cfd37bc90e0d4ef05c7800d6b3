{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "92759d32_ebd0d892",
        "filename": "src/serialization.c",
        "patchSetId": 3
      },
      "lineNbr": 979,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-06-29T10:17:36Z",
      "side": 1,
      "message": "(nitpick) where does that 4 * sizeof(u) comes from? :D\nI mean, it works (and even better for octal than I was checking decimals at first...), but it feels bit \"sorti du chapeau\"... Well okay really just nitpicking here, it was fun to see",
      "revId": "26846b0b690d46cfd37bc90e0d4ef05c7800d6b3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fc77965_fc62c665",
        "filename": "src/serialization.c",
        "patchSetId": 3
      },
      "lineNbr": 979,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-06-29T21:04:21Z",
      "side": 1,
      "message": "It\u0027s what I used in miniyaml for yaml_emit_integer().\n\nThe logic there was that I wanted a size:\n- big enough that it would fit any number I wanted to write (in base10);\n- statically computed so the compiler could make all sorts of optimizations;\n- neatly \"computer-round\" (so a power of 2).\n\nThe first example I took a look at was int32_t:\n- sizeof(int32_t) \u003d\u003d 4\n- strlen(string(INT32_MIN)) + 1 \u003d\u003d 11\n\n4 * 2 is not enough\n4 * 3 is not \"round\" enough\n4 * 4 is perfect. ðŸ˜Š\n\nThe bigger the number, the better it scales, so I also check the worst case scenario: -1 for an int8_t, it worked, I was happy to go with that.\n\nAnyway, I did not realize the computation for octals would be different, so I\u0027m quite lucky it works out. Or maybe I did run the numbers and I just forgot...",
      "parentUuid": "92759d32_ebd0d892",
      "revId": "26846b0b690d46cfd37bc90e0d4ef05c7800d6b3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}
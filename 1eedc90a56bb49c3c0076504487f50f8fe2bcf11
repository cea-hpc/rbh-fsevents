{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "13cb6252_cc64a1d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-06-27T21:39:11Z",
      "side": 1,
      "message": "(not reviewed yet) do you have any sample yaml file that\u0027d sort of work for this? I\u0027m in another fuzzing period so would be glad to play with it if you haven\u0027t yet\nIf you don\u0027t I\u0027ll write one, I just don\u0027t see any test and wondered how far you got",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f74c511_83378e25",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-06-27T23:46:54Z",
      "side": 1,
      "message": "Yep, sure. This is the code I use, you should be able to compile it against src/serialization.o (may need one or two adjustments, not quite sure):\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \u003cerrno.h\u003e\n#include \u003cerror.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cunistd.h\u003e\n\n#include \u003csys/stat.h\u003e\n\n#include \u003cminiyaml.h\u003e\n\n#include \"serialization.h\"\n\nstatic void __attribute__((noreturn))\nemitter_error(yaml_emitter_t *emitter)\n{\n    error(EXIT_FAILURE, 0, \"emitter error: %s\\n\", emitter-\u003eproblem);\n    __builtin_unreachable();\n}\n\nstatic yaml_emitter_t emitter;\n\nstatic void __attribute__((constructor))\nemitter_init(void)\n{\n    if (!yaml_emitter_initialize(\u0026emitter))\n        error(EXIT_FAILURE, 0, \"yaml_emitter_initialize\");\n\n    yaml_emitter_set_output_file(\u0026emitter, stdout);\n    yaml_emitter_set_unicode(\u0026emitter, true);\n\n    if (!yaml_emit_stream_start(\u0026emitter, YAML_UTF8_ENCODING))\n        emitter_error(\u0026emitter);\n}\n\nstatic void __attribute__((destructor))\nemitter_exit(void)\n{\n    yaml_emitter_delete(\u0026emitter);\n}\n\nstatic struct rbh_id *\nid_from_fd(int fd)\n{\n    size_t handle_size \u003d MAX_HANDLE_SZ;\n    struct file_handle *handle;\n    struct rbh_id *id;\n    int _;\n\nretry:\n    handle \u003d malloc(handle_size);\n    if (handle \u003d\u003d NULL)\n        error(EXIT_FAILURE, errno, \"malloc\");\n    handle-\u003ehandle_bytes \u003d handle_size - sizeof(handle);\n\n    if (name_to_handle_at(fd, \"\", handle, \u0026_, AT_EMPTY_PATH)) {\n        if (errno \u003d\u003d EOVERFLOW) {\n            do {\n                if (handle_size \u003e SIZE_MAX / 2) {\n                    handle_size \u003d SIZE_MAX;\n                    break;\n                }\n                handle_size *\u003d 2;\n            } while (handle-\u003ehandle_bytes \u003e handle_size - sizeof(handle));\n\n            goto retry;\n        }\n        error(EXIT_FAILURE, errno, \"name_to_handle_at()\");\n    }\n\n    id \u003d rbh_id_from_file_handle(handle);\n    if (id \u003d\u003d NULL)\n        error(EXIT_FAILURE, errno, \"rbh_id_from_file_handle\");\n\n    free(handle);\n    return id;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    const int STATX_FLAGS \u003d AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW\n                          | AT_NO_AUTOMOUNT | AT_STATX_FORCE_SYNC;\n\n    for (int i \u003d 1; i \u003c argc; i++) {\n        struct rbh_fsevent *fsevent;\n        struct statx statxbuf;\n        struct rbh_id *id;\n        int save_errno;\n        int fd;\n\n        fd \u003d open(argv[i], O_RDONLY | O_PATH | O_NOFOLLOW);\n        if (fd \u003c 0)\n            error(EXIT_FAILURE, errno, \"opening \u0027%s\u0027\", argv[i]);\n\n        id \u003d id_from_fd(fd);\n\n        if (statx(fd, \"\", STATX_FLAGS, STATX_ALL, \u0026statxbuf))\n            error(EXIT_FAILURE, errno, \"statx\");\n\n        fsevent \u003d rbh_fsevent_upsert_new(id, NULL, \u0026statxbuf, NULL);\n        save_errno \u003d errno;\n        if (fsevent \u003d\u003d NULL)\n            error(EXIT_FAILURE, save_errno, \"rbh_fsevent_upsert_new\");\n\n        if (!emit_fsevent(\u0026emitter, fsevent))\n            emitter_error(\u0026emitter);\n\n        free(fsevent);\n        free(id);\n        if (close(fd))\n            error(EXIT_FAILURE, errno, \"closing \u0027%s\u0027\", argv[i]);\n    }\n\n    return EXIT_SUCCESS;\n}\n\n------\n\nAnd here is an example of what it\u0027s supposed to do:\n\n$ ./fsevent2yaml path/to/dir\n--- !upsert\n\"id\": !!binary TQAAAAGnUAAAAAAABQAAAAAAAAA1BgQA\n\"xattrs\": {}\n\"statx\":\n  \"type\": \"directory\"\n  \"mode\": 0755\n  \"nlink\": 1\n  \"uid\": 1000\n  \"gid\": 1000\n  \"atime\":\n    \"sec\": 1624836429\n    \"nsec\": 613923583\n  \"mtime\":\n    \"sec\": 1624836429\n    \"nsec\": 557255860\n  \"ctime\":\n    \"sec\": 1624836429\n    \"nsec\": 557255860\n  \"ino\": 5285633\n  \"size\": 178\n  \"blocks\": 0\n  \"btime\":\n    \"sec\": 1603015523\n    \"nsec\": 356711918\n  \"blksize\": 4096\n  \"attributes\":\n    \"compressed\": n\n    \"immutable\": n\n    \"append\": n\n    \"nodump\": n\n  \"rdev\":\n    \"major\": 0\n    \"minor\": 0\n  \"dev\":\n    \"major\": 0\n    \"minor\": 40\n...",
      "parentUuid": "13cb6252_cc64a1d3",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a40ed6f_fe6acca4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-06-27T23:59:33Z",
      "side": 1,
      "message": "It cannot hurt to share the meson configuration to compile the snippet above:\n\n executable(\n     \u0027fsevent2yaml\u0027,\n     sources: [\n         \u0027fsevent2yaml.c\u0027,\n         \u0027src/serialization.c\u0027,\n     ],\n     include_directories: includes,\n     dependencies: [librobinhood, libyaml, miniyaml],\n     install: true,\n )\n\nWith that you should be able to check that:\n\n $ ./fsevent2yaml . | ./rbh-fsevents - - | diff - \u003c(./fsevent2yaml .)\n\nEDIT: tested it, found a bug, fixed the bug. 😊",
      "parentUuid": "4f74c511_83378e25",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "50f8a8df_0d735589",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-06-28T11:48:03Z",
      "side": 1,
      "message": "Started fuzzing a bit... There\u0027s actually a conceptual problem in that it considers assert failures as crash and we do assert based on input (e.g. expect tag to be this or that value).\n\nShould the code just skip bad events instead of asserting?\n\nIn practice if we\u0027re only consuming events we produced ourselves I believe it\u0027s fine to assert, if it ever happens it\u0027ll signal a strong problem rather than just skipping events.\n\n\nThat said it also found a real SEGV (only with asan, interesting.. didn\u0027t look into it yet)\n\n$ base64 -d \u003c\u003c EOF | unxz \u003e input\n/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4AgXAY5dABboBAQq5pOE+XIpsHGsMheANitRR6bJLERu\n93gJ3wR7j/01ipdpC934pbRKEt85DKrAVKc04AMfDNhKxxI/L6Jtf3bdBu34Z9y/RdTIZZGQAhd9\nHC6a9z7vbXVdWmLQs+XDJt44s0uqr6zcw5ReS5cudZCiP5a70yxvrIVf9Gdfc3xlOIUYFHlChQVr\nMqWLNrO8QQVLmQ9UHvA7js7kJjEPAebGY/f8hzhUEnSD2DzbTtR7VbVV/rSrxoUWUa3TiYVVBDHR\nJ2zIfOFislRT8pu6H/tOHcbizWz/tk4kvO/462TF5PRkAvIl/E9ypaX3XmUSvaF+wp/PmUhYv6o7\nfkRZhw4tEwrTL8TVboKZH844CjPevBFg8xZnJ8X+I7+44GpQf05hkbNam7L7U3U4NGzGQrreHh7m\nG77UnyBTGnowLpk7s76UUJaQLWCRL6PSIBsl8gPqPlsogVkU5/9cev/+ZTUVE+fgTfQKEqhvofAX\nmXHXHjaPTEBOIDEkzesLhrPBiPWmZqb0C/xh74IAAAAAhAuL+BrlrmQAAaoDmBAAAL72oFixxGf7\nAgAAAAAEWVo\u003d\nEOF\n$ rbh-fsevents input -\nAddressSanitizer:DEADLYSIGNAL\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\u003d\u003d2960184\u003d\u003dERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000407224 bp 0x7fffea6fbc60 sp 0x7fffea6fbc40 T0)\n\u003d\u003d2960184\u003d\u003dThe signal is caused by a READ memory access.\n\u003d\u003d2960184\u003d\u003dHint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\n    #0 0x407224 in emit_rbh_value_map ../src/serialization.c:453\n    #1 0x40eea4 in emit_upsert ../src/serialization.c:2060\n    #2 0x411fb5 in emit_fsevent ../src/serialization.c:2694\n    #3 0x413a1a in file_sink_process ../src/sinks/file.c:35\n    #4 0x402879 in sink_process ../include/sink.h:26\n    #5 0x402ebd in feed ../rbh-fsevents.c:166\n    #6 0x40359b in main ../rbh-fsevents.c:226\n    #7 0x7f1a4fcf5b74  (/lib64/libc.so.6+0x27b74)\n    #8 0x40249d in _start (/home/shared/robinhood/rbh-fsevents/build_asan/rbh-fsevents+0x40249d)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV ../src/serialization.c:453 in emit_rbh_value_map\n\u003d\u003d2960184\u003d\u003dABORTING\n\n\nah, valgrind is more useful:\n\u003d\u003d2992570\u003d\u003d Conditional jump or move depends on uninitialised value(s)\n\u003d\u003d2992570\u003d\u003d    at 0x403F0E: emit_rbh_value_map (serialization.c:450)\n\u003d\u003d2992570\u003d\u003d    by 0x40735E: emit_upsert (serialization.c:2060)\n\u003d\u003d2992570\u003d\u003d    by 0x408747: emit_fsevent (serialization.c:2694)\n\u003d\u003d2992570\u003d\u003d    by 0x40920E: file_sink_process (file.c:35)\n\u003d\u003d2992570\u003d\u003d    by 0x402539: sink_process (sink.h:26)\n\u003d\u003d2992570\u003d\u003d    by 0x40290B: feed (rbh-fsevents.c:166)\n\u003d\u003d2992570\u003d\u003d    by 0x402B9B: main (rbh-fsevents.c:226)\n\nso it\u0027s an upsert with xattrs uninitialized because xattrs had been commented out, I guess the reset code in yaml_fsevent_iter_next and yaml_fsevent_init should be a bit more thoroughful with zeroing the struct... (it\u0027s on first element, so type \u003d 0 and only init\u0027s init is used)",
      "parentUuid": "1a40ed6f_fe6acca4",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a7b437c_5df249f4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-06-29T01:00:07Z",
      "side": 1,
      "message": "Really cool that you\u0027re fuzzing this! This is really what we need! ❤️\n\nI\u0027m un-resolving this comment to remember to check that replacing the switch statement with a memset() fixed that crash.",
      "parentUuid": "50f8a8df_0d735589",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb2cc788_494c6d1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-07-08T23:02:06Z",
      "side": 1,
      "message": "Going to assume it was a fix ^^",
      "parentUuid": "0a7b437c_5df249f4",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}
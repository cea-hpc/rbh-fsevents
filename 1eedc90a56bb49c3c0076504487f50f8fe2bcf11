{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "13cb6252_cc64a1d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-06-27T21:39:11Z",
      "side": 1,
      "message": "(not reviewed yet) do you have any sample yaml file that\u0027d sort of work for this? I\u0027m in another fuzzing period so would be glad to play with it if you haven\u0027t yet\nIf you don\u0027t I\u0027ll write one, I just don\u0027t see any test and wondered how far you got",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f74c511_83378e25",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-06-27T23:46:54Z",
      "side": 1,
      "message": "Yep, sure. This is the code I use, you should be able to compile it against src/serialization.o (may need one or two adjustments, not quite sure):\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \u003cerrno.h\u003e\n#include \u003cerror.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cunistd.h\u003e\n\n#include \u003csys/stat.h\u003e\n\n#include \u003cminiyaml.h\u003e\n\n#include \"serialization.h\"\n\nstatic void __attribute__((noreturn))\nemitter_error(yaml_emitter_t *emitter)\n{\n    error(EXIT_FAILURE, 0, \"emitter error: %s\\n\", emitter-\u003eproblem);\n    __builtin_unreachable();\n}\n\nstatic yaml_emitter_t emitter;\n\nstatic void __attribute__((constructor))\nemitter_init(void)\n{\n    if (!yaml_emitter_initialize(\u0026emitter))\n        error(EXIT_FAILURE, 0, \"yaml_emitter_initialize\");\n\n    yaml_emitter_set_output_file(\u0026emitter, stdout);\n    yaml_emitter_set_unicode(\u0026emitter, true);\n\n    if (!yaml_emit_stream_start(\u0026emitter, YAML_UTF8_ENCODING))\n        emitter_error(\u0026emitter);\n}\n\nstatic void __attribute__((destructor))\nemitter_exit(void)\n{\n    yaml_emitter_delete(\u0026emitter);\n}\n\nstatic struct rbh_id *\nid_from_fd(int fd)\n{\n    size_t handle_size \u003d MAX_HANDLE_SZ;\n    struct file_handle *handle;\n    struct rbh_id *id;\n    int _;\n\nretry:\n    handle \u003d malloc(handle_size);\n    if (handle \u003d\u003d NULL)\n        error(EXIT_FAILURE, errno, \"malloc\");\n    handle-\u003ehandle_bytes \u003d handle_size - sizeof(handle);\n\n    if (name_to_handle_at(fd, \"\", handle, \u0026_, AT_EMPTY_PATH)) {\n        if (errno \u003d\u003d EOVERFLOW) {\n            do {\n                if (handle_size \u003e SIZE_MAX / 2) {\n                    handle_size \u003d SIZE_MAX;\n                    break;\n                }\n                handle_size *\u003d 2;\n            } while (handle-\u003ehandle_bytes \u003e handle_size - sizeof(handle));\n\n            goto retry;\n        }\n        error(EXIT_FAILURE, errno, \"name_to_handle_at()\");\n    }\n\n    id \u003d rbh_id_from_file_handle(handle);\n    if (id \u003d\u003d NULL)\n        error(EXIT_FAILURE, errno, \"rbh_id_from_file_handle\");\n\n    free(handle);\n    return id;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    const int STATX_FLAGS \u003d AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW\n                          | AT_NO_AUTOMOUNT | AT_STATX_FORCE_SYNC;\n\n    for (int i \u003d 1; i \u003c argc; i++) {\n        struct rbh_fsevent *fsevent;\n        struct statx statxbuf;\n        struct rbh_id *id;\n        int save_errno;\n        int fd;\n\n        fd \u003d open(argv[i], O_RDONLY | O_PATH | O_NOFOLLOW);\n        if (fd \u003c 0)\n            error(EXIT_FAILURE, errno, \"opening \u0027%s\u0027\", argv[i]);\n\n        id \u003d id_from_fd(fd);\n\n        if (statx(fd, \"\", STATX_FLAGS, STATX_ALL, \u0026statxbuf))\n            error(EXIT_FAILURE, errno, \"statx\");\n\n        fsevent \u003d rbh_fsevent_upsert_new(id, NULL, \u0026statxbuf, NULL);\n        save_errno \u003d errno;\n        if (fsevent \u003d\u003d NULL)\n            error(EXIT_FAILURE, save_errno, \"rbh_fsevent_upsert_new\");\n\n        if (!emit_fsevent(\u0026emitter, fsevent))\n            emitter_error(\u0026emitter);\n\n        free(fsevent);\n        free(id);\n        if (close(fd))\n            error(EXIT_FAILURE, errno, \"closing \u0027%s\u0027\", argv[i]);\n    }\n\n    return EXIT_SUCCESS;\n}\n\n------\n\nAnd here is an example of what it\u0027s supposed to do:\n\n$ ./fsevent2yaml path/to/dir\n--- !upsert\n\"id\": !!binary TQAAAAGnUAAAAAAABQAAAAAAAAA1BgQA\n\"xattrs\": {}\n\"statx\":\n  \"type\": \"directory\"\n  \"mode\": 0755\n  \"nlink\": 1\n  \"uid\": 1000\n  \"gid\": 1000\n  \"atime\":\n    \"sec\": 1624836429\n    \"nsec\": 613923583\n  \"mtime\":\n    \"sec\": 1624836429\n    \"nsec\": 557255860\n  \"ctime\":\n    \"sec\": 1624836429\n    \"nsec\": 557255860\n  \"ino\": 5285633\n  \"size\": 178\n  \"blocks\": 0\n  \"btime\":\n    \"sec\": 1603015523\n    \"nsec\": 356711918\n  \"blksize\": 4096\n  \"attributes\":\n    \"compressed\": n\n    \"immutable\": n\n    \"append\": n\n    \"nodump\": n\n  \"rdev\":\n    \"major\": 0\n    \"minor\": 0\n  \"dev\":\n    \"major\": 0\n    \"minor\": 40\n...",
      "parentUuid": "13cb6252_cc64a1d3",
      "revId": "1eedc90a56bb49c3c0076504487f50f8fe2bcf11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}
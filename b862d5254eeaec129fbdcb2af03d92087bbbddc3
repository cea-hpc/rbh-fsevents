{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a9370174_c28d24d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-21T21:32:49Z",
      "side": 1,
      "message": "I recommend reading the file on github: https://github.com/cea-hpc/rbh-fsevents/blob/b862d5254eeaec129fbdcb2af03d92087bbbddc3/doc/adr/partial-fsevents.rst",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "106ee703_2693d1b8",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 76,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-21T22:46:32Z",
      "side": 1,
      "message": "missing rbh-fsevents key?",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fdc966c_b3346473",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 76,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-22T19:24:52Z",
      "side": 1,
      "message": "Yes, done",
      "parentUuid": "106ee703_2693d1b8",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdd2aa47_5a5d242e",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-21T22:46:32Z",
      "side": 1,
      "message": "(nit) trailing space",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "604df21a_15341652",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 111,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-22T19:24:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bdd2aa47_5a5d242e",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "181d7520_0e7ea062",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 132,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-21T22:46:32Z",
      "side": 1,
      "message": "(slightly off-topic) iirc there is a distinction for ns xattr and inode xattr, how is that represented for fsevents again? xattrs: ns: path?",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06524f94_eb0752ed",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 132,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-22T19:24:52Z",
      "side": 1,
      "message": "To distinguish whether an RBH_FET_XATTR fsevent is an inode_xattr or an ns_xattr, one has to check whether `fsevent-\u003ens.parent` and `fsevent-\u003ens.name` are set or not.\n\nref: https://github.com/cea-hpc/librobinhood/blob/main/include/robinhood/fsevent.h#L66\n\nIn practice, namespace xattrs are stored under a special `ns` xattr in the mongodb backend, but this is an implementation detail.",
      "parentUuid": "181d7520_0e7ea062",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e6d696c_e73d36b8",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 139,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-21T22:46:32Z",
      "side": 1,
      "message": "What are cases where entry is type S_IFLNK and we don\u0027t want to enrich symlink data for upsert?\nNote symlinks are immutable in content, so we only actually need that data on creation, but depending on the event source we might not be able to determine if it is a new one (possible for lustre changelog, probably not for fanotify?)",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d45ba07e_d0582734",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 139,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-22T19:24:52Z",
      "side": 1,
      "message": "\u003e What are cases where entry is type S_IFLNK and we don\u0027t want to enrich symlink data for upsert?\n\nWhen the content of the symlink is known from the event emitted by the filesystem. I don\u0027t know if any filesystem supports this, but I can imagine that being a thing. With possibly weird variations where only small symlink contents are emitted while larger symlinks still need to be queried (as a performance optimization).\n\n\u003e Note symlinks are immutable in content, so we only actually need that data on creation, but depending on the event source we might not be able to determine if it is a new one?\n\nI consider this to be the responsibility of the \"source\". If it sets `xattr.rbh-fsevents.symlink`, the enricher will query the FS, if not, we assume everything is already in the backend.",
      "parentUuid": "4e6d696c_e73d36b8",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77c16f0a_78134579",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-21T22:46:32Z",
      "side": 1,
      "message": "So the point is to partially fill a struct statx from the event source, and let a further enrich only statx missing fields?\nsentinels or relying on statx mask (extending it for mandatory values, which are an implementation detail and not really mandatory to robinhood) sounds simpler than having to imlpement a \"look in xattr tree and merge\" thing to me, but as long as performances are OK I\u0027d say just do whatever is easier for you at this point. This can be further worked on later on if it turns out to be a bottleneck.",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97e8b917_45041b01",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-22T19:24:52Z",
      "side": 1,
      "message": "\u003e So the point is to partially fill a struct statx from the event source, and let a further enrich only statx missing fields?\n\nYes, mostly.\n\n\u003e sentinels or relying on statx mask (extending it for mandatory values, which are an implementation detail and not really mandatory to robinhood) sounds simpler than having to imlpement a \"look in xattr tree and merge\"\n\nI don\u0027t necessarily agree with the \"simpler\" qualifier, the approach I describe in this document requires no changes on the YAML source and sink (they could do with a couple optimization, like making sure the first xattr in the `struct rbh_value_map` is always `rbh-fsevents`, so we don\u0027t have to traverse the whole map looking for it, but it\u0027s not a requirement).\n\nBut most importantly, how do you define a sentinel on `statx.stx_size` for example? In YAML, it\u0027s super easy, but as soon as you load stuff in memory, it becomes a pain to make defined/undefined values coexist.\n\nIf `statx.stx_mask` contains `STX_SIZE`, does it mean the size is known and set, or should it be queried from the filesystem? You could say `stx_size \u003d\u003d SIZE_MAX` implies the size is unknown, but anyone could `truncate -s SIZE_MAX file` (not the end of the world, we just query the filesystem for nothing in this case). The point is, most fields in `struct statx` cannot define a sentinel value.\n\nThe exception is `stx_mask` (32 bits, only 12 currently used), we could shift the bit flags 16 bits to the left and use this to mean \"field \u0027\u003cbitflag\u003e \u003e\u003e 16\u0027 is undefined\". But this is not portable and 12 is dangerously close to 16 IMO.\n\nAll in all, the xattr overload looked more appealing to me.\n\n\u003e as long as performances are OK I\u0027d say just do whatever is easier for you at this point\n\nAgreed. For the record, `rbh-fsevents - - \u003e /dev/null` clocks at about 7k events per second on my 1.6GHz machine. That is without deduplication. ðŸ˜Š\n\nSerialization is quite fast as well, with about 18k events per seconds.",
      "parentUuid": "77c16f0a_78134579",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81555d9e_475129b2",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1019142
      },
      "writtenOn": "2021-08-23T07:21:38Z",
      "side": 1,
      "message": "This may be a weird solution but wouldn\u0027t it be simpler (not necessarily in terms of implementation) to have the missing information stored as a bit field. Either by having a seperate integer somewhere linked to an entry or by setting an xattr.rbh-fsevents.statx (or something like that).\n\nSo that when querying information, you look at this field and do the appropriate queries. This would solve the issue you mentioned with the `stx_mask` and the difficulty of defining `undefined` values for each field without relying on the YAML format which seams a bit overkill in my opinion.",
      "parentUuid": "97e8b917_45041b01",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6370bb6b_59e1043c",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-23T18:55:21Z",
      "side": 1,
      "message": "If by bit field you mean something like:\n\n    xattrs:\n        rbh-fsevents:\n            statx: 0b00001101011\n\nNo, because some exotic architecture may define STATX_SIZE to be 0x1 where another will define it as 0x2. Also, I prefer to keep the YAML serialization format as human readable as possible.\n\nAnyway, there isn\u0027t that much complexity involved in parsing this:\n\n    xattrs:\n        rbh-fsevents:\n            statx:\n              - size\n              - mode\n\nInto:\n\n    stx_mask \u003d STATX_SIZE | STATX_MODE;\n\nWhat\u0027s maybe unclear is why we need to support the map format in addition to the sequence format. Couldn\u0027t we always store the \"known\" fields in `upsert.statx` and the unknown fields in `xattrs.rbh-fsevent.statx`?\n\nThe answer is no, because there are fields in `struct statx` which are not covered by `stx_mask` (eg. `stx_rdev_major`, `stx_rdev_minor`, ...).\n\nThis means that if I know the size of an inode but not its device number and I send something like:\n\n    upsert.statx \u003d {\n        .stx_mask \u003d STATX_SIZE,\n        .stx_size \u003d 1024,\n    }\n\nTo a robinhood backend, the device numbers of the inode will be set to 0.\n\nIs this a design flaw in robinhood? Maybe. Maybe we should define our own `struct statx` with some additional flags like `STATX_RDEV_MAJOR`, `STATX_RDEV_MINOR`, ... But fixing this is definitely not a priority for me.",
      "parentUuid": "81555d9e_475129b2",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71901bbf_af4ff0b8",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1019142
      },
      "writtenOn": "2021-08-24T06:58:06Z",
      "side": 1,
      "message": "Yes, that\u0027s what I meant bit field. Regarding the possible value of STATX_SIZE and other fields, I was thinking that the value of each bit is controlled by robinhood, not the statx\u0027s values (e.g. by creating RBH_STATX_SIZE, ...). And again, if understand the issue with device numbers correctly, you could define them as well.\n\nI don\u0027t know enough about robinhood but if the \u0027sender\u0027 and the \u0027receiver\u0027 have access to robinhood\u0027s header files, it seems much easier to me. You could then just send the bit mask and the values?\n\nRegarding the fact that you need a map because of device numbers for example. If, as I said, you define your own RBH_STAX_... values you can then just send the sequence?",
      "parentUuid": "6370bb6b_59e1043c",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97686eaf_40e2a4ff",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-24T19:33:10Z",
      "side": 1,
      "message": "\u003e If, as I said, you define your own RBH_STAX_... values\n\nWell, I said it first:\n\n\u003e \u003e Maybe we should define our own `struct statx` with some additional flags like `STATX_RDEV_MAJOR`, `STATX_RDEV_MINOR`, ...\n\nAnd I also added:\n\n\u003e \u003e But fixing this is definitely not a priority for me.\n\nðŸ˜œ\n\nBut alright, let\u0027s try and get to the root of this then: why do you think we should define our own `struct statx`, or at least our own flags, and use a bit field rather than a sequence of strings?\n\nAre you worried about having to implement a \"source\" for Lustre changelog records and this decision making it hard for you?\n\nOtherwise, is there an advantage to your approach that makes it superior enough that mine is not worth implementing?\n\nBoth valid reason to push back, but I would appreciate it if you could explicit why you believe your suggestion is better.\n\nIMO your approach would be marginally more performant, but would incur a cost in readability, and time to implement the feature.",
      "parentUuid": "71901bbf_af4ff0b8",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c728159_d885b127",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-24T21:45:13Z",
      "side": 1,
      "message": "The main advantage of having our own statx mask (which is what I had suggested as well if there\u0027s any doubt, might not have been clear) for me is that we might have cases where we don\u0027t need to issue any statx at all.\n\nWith the current code and your design, if an event partially fills some of the statx fields for update (e.g. we know the new file size), then we must issue a statx to fill the mandatory fields before updating the info in the db (otherwise mandatory fields will be zeroed out and made invalid)\nIf we have our own statx mask then we can just say only size is valid and only update that field. Am I wrong?\n\nImplementation wise also really seems simpler to me.\nIt doesn\u0027t require dupliating the 14 bits, just adding four more bits towards the unused end (blksize, attributes, dev and rdev are the only four?) -- so it\u0027s really just adding a few extra flags in our statx header that would get defined unconditionally, and extending the parsing code to check/set the bits, we\u0027re talking ~50 lines of code added that look like the rest of the code in total...",
      "parentUuid": "97686eaf_40e2a4ff",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d07ffb2_d971b8f7",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-25T00:12:02Z",
      "side": 1,
      "message": "\u003e which is what I had suggested as well if there\u0027s any doubt\n\nI did not understand, but my bad, I should have asked about it.\n\n\u003e If we have our own statx mask then we can just say only size is valid and only update that field. Am I wrong?\n\nNo, that sounds correct to me.\n\n\u003e we\u0027re talking ~50 lines of code added that look like the rest of the code in total...\n\nThe mongo backends needs updating as well, otherwise the flags won\u0027t be taken into account... And then we need to update rbh-sync to use the flags or data will be missing from the mongo backend... Damn! I knew this was going to come back and haunt me. ðŸ˜ž\n\nAlright, let\u0027s assume we\u0027ll implement things that way _eventually_. What does it mean for the design _right now_?\n\nWe can give up the map syntax and only support the sequence of string that acts as a bit field (I am still not sold on using an actual bit field rather than text).\nThe rest pretty much still holds, right?\n\n----------\n\nI really don\u0027t want to deal with the refactoring of defining new flags right now, but do we absolutely need them at day-1?\n\nWe can pay the extra statx calls for a while, and once we define the flags, the refactoring will look like:\n- add the parsing/emitting code for the flags;\n- skip the call to statx unless it\u0027s needed.\n\nSold for ~50 lines! ðŸ˜„\n\nThe goal of this document is to give developers guidelines on the input `rbh-fsevents` expects so people from other projects can start contributing \"sources\". I\u0027m fine with us cutting some _internal_ corners and sacrificing performance here and there, so long as we can smooth things out later.\n\nEDIT: Oh shoot! We need the flags for sources to be able to use them... #@#$\"!#$\n\n... Alright, lazy me says:\n- we add a patch to librobinhood to define the flags but we don\u0027t update the backends;\n- we edit the YAML source/sink to parse/emit them in textual form;\n- and once we code the enricher we always call statx and we filter out the rbh-specific flags.\n\nStill... That makes the refactoring a priority. ðŸ˜ž",
      "parentUuid": "2c728159_d885b127",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cea118aa_222b2a92",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-08-25T00:15:31Z",
      "side": 1,
      "message": "Oh, and I assume that if we get these new flags for fsevents, fsentries have to be updated as well...\n\n...\n\n...\n\nGreat.",
      "parentUuid": "9d07ffb2_d971b8f7",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02c8e84a_33f17ea3",
        "filename": "doc/adr/partial-fsevents.rst",
        "patchSetId": 5
      },
      "lineNbr": 160,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-08-25T00:26:38Z",
      "side": 1,
      "message": "Yes, if we want the flags eventually then we need them in the librobinhood defines first, then yaml parser as you say.\nUpdating backend and tools can come later (err I think that ~50 lines estimate was just for librobinhood core + backends and didn\u0027t include the existing tools, can\u0027t remember where I did my grep on another flag)\n\nI don\u0027t think it\u0027s that big of a change, and I think it\u0027s better done now than later if that\u0027s what we want, but it is a change of priority as you say.\n\n\nRe-what it means for the rest:\n - symlinks still need a flag to request enriching vs. tell enricher it\u0027s already in backend; we can\u0027t really store it in a statx mask can we? I don\u0027t have any better idea than your xattr suggestion... sentinel value? a symlink cannot be empty, so differentiate between NULL and \"\" ?\n - partial xattrs (e.g. difference between \"just one xattr has been set/delete\" and \"this is the full list of xattrs of the inode, any xattr not listed is to be deleted\") -- how do we represent that?",
      "parentUuid": "cea118aa_222b2a92",
      "revId": "b862d5254eeaec129fbdcb2af03d92087bbbddc3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}